import osimport shutilimport sysimport torchfrom torch import nnfrom torch.autograd import Functionimport progressbarsys.path.append("../pytorch_autoencoder")from utils.util import run_perf_sum_score, apply_perf_threadclass Perf_match(Function):    @staticmethod    def forward(ctx, label, input):        out = torch.ones_like(input)        # ctx.save_for_backward(input)        numpy_label = label.detach().numpy()        numpy_input = input.detach().numpy()        perf_result = torch.tensor(apply_perf_thread(numpy_label, numpy_input, 8))        perf_result = perf_result.unsqueeze(1)        perf_result = perf_result.unsqueeze(2)        perf_result = perf_result.unsqueeze(3)        out = torch.mul(out, perf_result)        return out    @staticmethod    def backward(ctx, grad_output):        return grad_output, grad_outputdef criterion_perf(label, input):    perf_result = Perf_match.apply(label, input)    target = torch.ones_like(input) * 60000    perf_loss = nn.L1Loss()(perf_result, target)    return perf_lossdef output_ae_imgs(fpdbindex_path, fpdbindex_data, PerfDataset, model, device):    root_dir = os.path.dirname(fpdbindex_path)    out_dir = root_dir + "_AE"    shutil.rmtree(out_dir, ignore_errors=True)    for fpdb in fpdbindex_data:        ipp_path = os.path.join(root_dir, fpdb['path'])        raw = torch.tensor(PerfDataset.get_img(ipp_path))        raw = raw.unsqueeze(0)        raw = raw.unsqueeze(1)        model.eval()        with torch.no_grad():            raw_ae = model(raw.to(device=device)).cpu()        raw_ae = torch.squeeze(raw_ae).detach().numpy()        out_path = os.path.join(out_dir, fpdb['path'])        PerfDataset.save_img(raw_ae, out_path)        pass    sum_score, score_array = run_perf_sum_score(out_dir)    print("test score = {}".format(sum_score))def output_ae_imgs_(DB_path, FingerprintDataset, model, device):    in_dir = DB_path    out_dir = in_dir + "_AE"    shutil.rmtree(out_dir, ignore_errors=True)    with progressbar.ProgressBar(max_value=FingerprintDataset.size) as bar:        for i in range(FingerprintDataset.size):            raw, ipp_path = FingerprintDataset.get_img_path(i)            raw = torch.tensor(raw)            raw = raw.unsqueeze(0)            raw = raw.unsqueeze(1)            model.eval()            with torch.no_grad():                raw_ae = model(raw.to(device=device)).cpu()            raw_ae = torch.squeeze(raw_ae).detach().numpy()            out_path = ipp_path.replace(in_dir, out_dir)            FingerprintDataset.save_img(raw_ae, out_path)            pass        bar.update(i)    sum_score, score_array = run_perf_sum_score(out_dir)    print("test score = {}".format(sum_score))if __name__ == '__main__':    pass